<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ProperTee Scratch</title>
</head>
<body>
    <h1>ProperTee Scratch</h1>
    
    <h3>Properties (JSON):</h3>
    <textarea id="properties" rows="5" cols="50">{"user": {"name": "Test", "score": 100}}</textarea>
    
    <h3>Script:</h3>
    <textarea id="script" rows="10" cols="50">/* Error Line Number Test */

// 테스트 1: 정상 실행
x = 10
y = 20
PRINT("x + y =", x + y)

// 테스트 2: 에러 발생 (라인 번호 확인)
// 다음 줄의 주석을 해제하면 에러 발생

// PRINT(unknownVar)  // Error at line 11: Variable 'unknownVar' is not defined

// result = "hello" + 5  // Error at line 13: Addition requires...

// obj = null
// PRINT(obj.name)  // Error at line 16: Cannot access property...

// function test(a) do
//     return a * 2
// end
// test(1, 2, 3)  // Error at line 21: Function 'test' expects 1 argument(s)...

PRINT("All tests passed!")
</textarea>
    
    <br><br>
    <button onclick="run()">Run</button>
    
    <h3>Output:</h3>
    <pre id="output"></pre>
    
    <!-- ProperTee 번들 로드 -->
    <script src="https://raw.githubusercontent.com/flatide/propertee-js/main/dist/propertee-bundle.js"></script>
    
    <script>
        // 에러 리스너
        class ErrorListener extends antlr4.error.ErrorListener {
            constructor() {
                super();
                this.errors = [];
            }
            syntaxError(recognizer, offendingSymbol, line, column, msg, err) {
                this.errors.push(`Line ${line}:${column} - ${msg}`);
            }
        }
        
        // 실행 함수
        function run() {
            const output = document.getElementById('output');
            const propertiesText = document.getElementById('properties').value;
            const scriptText = document.getElementById('script').value;
            
            // 출력 캡처를 위한 배열 (스코프 확장)
            const outputLines = [];
            
            try {
                // 1. Properties 파싱
                const properties = JSON.parse(propertiesText);
                
                // 2. Lexer & Parser
                const chars = new antlr4.InputStream(scriptText);
                const lexer = new ProperTeeLexer(chars);
                const lexerErrors = new ErrorListener();
                lexer.removeErrorListeners();
                lexer.addErrorListener(lexerErrors);
                
                const tokens = new antlr4.CommonTokenStream(lexer);
                const parser = new ProperTeeParser(tokens);
                const parserErrors = new ErrorListener();
                parser.removeErrorListeners();
                parser.addErrorListener(parserErrors);
                
                const tree = parser.root();
                
                // 에러 체크
                if (lexerErrors.errors.length > 0) {
                    output.textContent = 'Lexer Error:\n' + lexerErrors.errors.join('\n');
                    return;
                }
                if (parserErrors.errors.length > 0) {
                    output.textContent = 'Parser Error:\n' + parserErrors.errors.join('\n');
                    return;
                }
                
                // 3. 출력 스트림 설정
                const ioStreams = {
                    stdout: (...args) => outputLines.push(args.join(' ')),
                    stderr: (...args) => outputLines.push('[ERROR] ' + args.join(' '))
                };
                
                
                const options = {
                    maxIterations: 1000,
                    iterationLimitBehavior: 'error'
                };
                
                // 5. Visitor 생성 및 실행
                const visitor = new ProperTeeCustomVisitor(properties, {}, ioStreams, options);
                const result = visitor.visit(tree);
                
                // 6. 결과 표시
                let resultText = outputLines.join('\n');
                resultText += '\n\n--- Return Value ---\n' + JSON.stringify(result, null, 2);
                resultText += '\n\n--- Properties ---\n' + JSON.stringify(properties, null, 2);
                resultText += '\n\n--- Variables ---\n' + JSON.stringify(visitor.variables, null, 2);
                
                output.textContent = resultText;
                
            } catch (e) {
                // 런타임 에러 발생 시 이전 출력도 함께 표시
                let errorText = '';
                if (outputLines && outputLines.length > 0) {
                    errorText += '--- Output Before Error ---\n';
                    errorText += outputLines.join('\n');
                    errorText += '\n\n';
                }
                errorText += '--- Runtime Error ---\n';
                errorText += 'Error: ' + e.message + '\n\n';
                errorText += e.stack;
                
                output.textContent = errorText;
            }
        }
    </script>
</body>
</html>
